## 1. 架构核心理念：认知并发 (Cognitive Concurrency)
借鉴经典操作系统的 UI-IO-Worker 模型，将 AI 的“思考”、“调研”与“执行”从物理与逻辑上彻底分离，通过共享的 `oxicodent-assistant.md`（状态总线）进行状态同步。

---

## 2. 三层分工模型

### 🧠 第一层：Reasoning (智囊/主控) - 对应 [UI 线程]
- **定位**：首席架构师，用户的直接对话者。
- **职责**：
    - 把握项目大方向与逻辑演进。
    - 维护思维连贯性，管理全局进度。
    - 下达任务指令给下级模块。
- **上下文策略**：动态压缩。仅保留历史关键决策与当前架构大纲，隔离具体实现噪音。

### 📝 第二层：Instruct (内勤/调研) - 对应 [IO 线程]
- **定位**：技术助理，处理高噪音、高延迟任务。
- **职责**：
    - 执行 Web Search (通过 SearXNG)。
    - 总结长篇 API 文档，提取核心代码契约。
    - 将调研结果转化为结构化简报（Briefing）。
- **上下文策略**：完全真空。单次任务完成后销毁，仅向 Markdown 快照输出纯净事实。

### 🛠️ 第三层：Coder (手术刀/执行) - 对应 [Worker 线程]
- **定位**：高级打字员，专注局部代码实现。
- **职责**：
    - 在受控范围内生成代码补丁 (Diff)。
    - 处理 Rust 严苛的类型系统与生命周期细节。
    - 与用户沟通代码层的微调建议。
- **上下文策略**：专注窗口。仅接收相关代码片段 + Instruct 提供的技术简报。

---

## 3. 数据流与状态同步 (The Bridge)

1. **任务分发**：Reasoning 产生意图 -> Instruct/Coder 接收任务。
2. **状态物化**：所有阶段性成果（API 简报、代码变更、架构决策）实时写入 `oxicodent-assistant.md`。
3. **异步刷新**：
    - 采用 `/refresh` 机制或程序重载。
    - Reasoning 通过重新读取 Markdown 快照来“对齐”最新现实，无需回溯杂乱的中间过程。

---

## 4. 架构优势
- **抗熵增**：有效防止长对话导致的“上下文毒化”与模型幻觉。
- **低成本**：允许针对不同层级选用不同规模的模型（如用 Flash 做 Instruct，用 R1 做 Reasoning）。
- **高确定性**：人作为“调度员”参与关键节点的 `/refresh` 与确认，确保 AI 始终在正确轨道。